{"version":3,"sources":["cpu/asm.js"],"names":["clear_line","code_line","trim","i","indexOf","slice","pre_process","asm_code","ret","length","code","concat","isValidCode","code_lines","split","line_nums","push","getValidCodeLines","asm","get_machine_code","Assembler","_classCallCheck","this","init","mcode","mcode_lines","label_map","Map","machine_code","get_registers","registers","std_code","valid_lines","data","line_index","Array","cnt","fill","label_cnt","instructions","low","reg","high","reg2","reg1","asm_data","apart_data","fillValidLine","asm_reg","parseInt","mem_addr","asm_reg1","asm_reg2","asm_reg3","isDigit","nex","addr","reg3","tag","set","fillZero","offset","has","get","Object","k"],"mappings":"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","file":"../../cpu/asm.js","sourcesContent":["var clear_line = function (code_line) {\n    // 清除一行的注释\n    code_line = code_line.trim()\n    i = code_line.indexOf(';')\n    if (i != -1) {\n        code_line = code_line.slice(0, i)\n    }\n    return code_line\n}\n\n\nvar pre_process = function (asm_code) {\n    // 预处理，功能仅仅是替换伪指令, 有一种情况是要考虑：函数作用域中可能也包含伪指令，要处理掉所有的\n    var ret = []\n    var asm_code = asm_code.split('\\n')\n    var i = 0\n\n    while (i < asm_code.length) {\n        var code = clear_line(asm_code[i])\n        if (code.length != 0) {\n            ret = ret.concat(code.split(' '))\n        }\n        i++\n    }\n    return ret\n}\n\nvar isValidCode = function (code) {\n    var code = code.trim()\n    // 注释、空行、label、函数都不是有效行\n    if (code.length == 0) {\n        return false\n    } else if (code[0] == ';' || code[0] == '#' || code[0] == '@') {\n        return false\n    }\n    return true\n}\n\n// 在汇编前将有效的源码（非空行、注释行）的行号记录下来，之后用机器码对应一个个行号\nvar getValidCodeLines = function (asm_code) {\n    var line_nums = []\n    var code_lines = asm_code.split('\\n')\n    for (var i = 0; i < code_lines.length; ++i) {\n        var code = code_lines[i]\n        if (isValidCode(code) == true) {\n            line_nums.push(i)\n        }\n    }\n    return line_nums\n}\n\n// 把Assembler架空\nvar machine_code = function (asm_code) {\n    var asm = Assembler.new(asm_code)\n    asm.run()\n    return asm.get_machine_code()\n}\n\nclass Assembler {\n    constructor(asm_code) {\n        this.source_code = asm_code\n        this.asm_code = asm_code\n\n        this.init()\n\n        this.mcode = []\n        this.mcode_lines = []\n        this.label_map = new Map()\n        this.instructions = get_instructions()\n        this.registers = get_registers()\n    }\n\n    static new(asm_code) {\n        var i = new this(asm_code)\n        return i\n    }\n\n    init() {\n        // 得到有效代码行号的目的是为了让机器码和汇编代码对应起来，做高亮\n        this.valid_lines = getValidCodeLines(this.asm_code)\n        // 有效代码行号是从0起\n        this.line_index = 0\n        // log('有效代码行号:', this.valid_lines)\n\n        // 翻译伪代码成标准汇编\n        this.std_code = translate_fake_ins(this.asm_code)\n        // log('标准代码:', this.std_code)\n        // 预处理:将标准代码转成一个个token\n        this.asm_code = pre_process(this.std_code)\n        // log('asm_code:', this.asm_code)\n    }\n\n    fillValidLine(cnt) {\n        var data = this.valid_lines[this.line_index]\n        this.mcode_lines = this.mcode_lines.concat(Array(cnt).fill(data))\n        this.line_index += 1\n    }\n\n    get_std_code() {\n        return this.std_code\n    }\n\n    get_machine_code() {\n        return this.mcode\n    }\n\n    get_valid_lines() {\n        return this.valid_lines\n    }\n    get_mcode_lines() {\n        return this.mcode_lines\n    }\n    get_labelmap() {\n        return this.label_map\n    }\n\n    run() {\n        // i是asm的下标\n        var i = 0\n        // 标记label的位置\n        var offset = 0\n        var label_map = this.label_map\n        var label_cnt = new Map()\n\n        var asm_code = this.asm_code\n        var mcode = []\n        var instructions = this.instructions\n        var registers = this.registers\n\n        while (i < asm_code.length) {\n            var code = asm_code[i].trim()\n            // set 寄存器 数值\n            if (code == 'set' || code == 'set2') {\n                mcode.push(instructions[code])\n\n                // 寄存器\n                let asm_reg = asm_code[i + 1]\n                let reg = registers[asm_reg]\n                mcode.push(reg)\n\n                // 数据\n                let asm_data = asm_code[i + 2]\n                let data = parseInt(asm_data)\n\n                data = apart_data(data)\n                let low = data[0]\n                let high = data[1]\n                if (code == 'set') {\n                    offset += 3\n                    mcode.push(low)\n                    this.fillValidLine(3)\n                } else {\n                    offset += 4\n                    mcode.push(low)\n                    mcode.push(high)\n                    this.fillValidLine(4)\n                }\n                i += 3\n            } else if (code == 'load' || code == 'load2') {\n                // load 内存地址 寄存器\n                mcode.push(instructions[code])\n\n                // 内存地址\n                let mem_addr = asm_code[i + 1]\n                let data = parseInt(mem_addr.slice(1))\n                data = apart_data(data)\n                let low = data[0]\n                let high = data[1]\n\n                if (code == 'load') {\n                    offset += 3\n                    mcode.push(low)\n                    this.fillValidLine(3)\n                } else {\n                    offset += 4\n                    mcode.push(low)\n                    mcode.push(high)\n                    this.fillValidLine(4)\n                }\n                let asm_reg = asm_code[i + 2]\n                let reg = registers[asm_reg]\n                mcode.push(reg)\n                i += 3\n\n            } else if (code == 'add' || code == 'add2') {\n                // add 寄存器1 寄存器2 寄存器3\n                mcode.push(instructions[code])\n                // 寄存器1\n                let asm_reg1 = asm_code[i + 1]\n                let reg1 = registers[asm_reg1]\n                mcode.push(reg1)\n                // 寄存器2\n                let asm_reg2 = asm_code[i + 2]\n                let reg2 = registers[asm_reg2]\n                mcode.push(reg2)\n                // 寄存器3\n                let asm_reg3 = asm_code[i + 3]\n                let reg3 = registers[asm_reg3]\n                mcode.push(reg3)\n\n                i += 4\n                offset += 4\n                this.fillValidLine(4)\n            } else if (code == 'save' || code == 'save2') {\n                // save 寄存器1 内存地址\n                mcode.push(instructions[code])\n\n                let asm_reg = asm_code[i + 1]\n                let reg = registers[asm_reg]\n                mcode.push(reg)\n\n                let mem_addr = asm_code[i + 2]\n                let data = parseInt(mem_addr.slice(1))\n                data = apart_data(data)\n                let low = data[0]\n                let high = data[1]\n\n                if (code == 'save') {\n                    offset += 3\n                    mcode.push(low)\n                    this.fillValidLine(3)\n                } else {\n                    offset += 4\n                    mcode.push(low)\n                    mcode.push(high)\n                    this.fillValidLine(4)\n                }\n                i += 3\n            } else if (code == 'compare') {\n                mcode.push(instructions[code])\n\n                let asm_reg1 = asm_code[i + 1]\n                let reg1 = registers[asm_reg1]\n                mcode.push(reg1)\n\n                let asm_reg2 = asm_code[i + 2]\n                let reg2 = registers[asm_reg2]\n                mcode.push(reg2)\n\n                i += 3\n                offset += 3\n                this.fillValidLine(3)\n            } else if (code == 'jump_if_less' || code == 'jump_if_great' || code == 'jump') {\n                mcode.push(instructions[code])\n                // 如果是地址则直接跳地址\n                let nex = asm_code[i + 1].slice(1)\n\n                if (isDigit(nex)) {\n                    let addr = parseInt(nex)\n                    let data = apart_data(addr)\n                    let low = data[0]\n                    let high = data[1]\n\n                    mcode.push(low)\n                    mcode.push(high)\n                } else {\n                    // 如果是label则跳label\n                    // 需要做排错判断，如果说这个label并没有定义的话，则要提醒\n                    label_cnt[asm_code[i + 1]] = false // 出现一次，必须在label_map中出现，才算定义了，否则报错\n                    mcode.push(asm_code[i + 1])\n                    mcode.push(0)\n                }\n                i += 2\n                offset += 3\n                // 因为jump都是16位的\n                this.fillValidLine(3)\n            } else if (code == 'save_from_register') {\n                mcode.push(instructions[code])\n\n                let asm_reg1 = asm_code[i + 1]\n                let reg1 = registers[asm_reg1]\n                mcode.push(reg1)\n\n                let asm_reg2 = asm_code[i + 2]\n                let reg2 = registers[asm_reg2]\n                mcode.push(reg2)\n                i += 3\n                offset += 3\n                this.fillValidLine(3)\n            } else if (code == 'subtract2') {\n                mcode.push(instructions[code])\n\n                let asm_reg1 = asm_code[i + 1]\n                let reg1 = registers[asm_reg1]\n                mcode.push(reg1)\n\n                let asm_reg2 = asm_code[i + 2]\n                let reg2 = registers[asm_reg2]\n                mcode.push(reg2)\n\n                let asm_reg3 = asm_code[i + 3]\n                let reg3 = registers[asm_reg3]\n                mcode.push(reg3)\n\n                i += 4\n                offset += 4\n                this.fillValidLine(4)\n            } else if (code == 'load_from_register' || code == 'load_from_register2') {\n                mcode.push(instructions[code])\n\n                let asm_reg1 = asm_code[i + 1]\n                let reg1 = registers[asm_reg1]\n                mcode.push(reg1)\n\n                let asm_reg2 = asm_code[i + 2]\n                let reg2 = registers[asm_reg2]\n                mcode.push(reg2)\n\n                i += 3\n                offset += 3\n                this.fillValidLine(3)\n            } else if (code == 'save_from_register2') {\n                mcode.push(instructions[code])\n\n                let asm_reg1 = asm_code[i + 1]\n                let reg1 = registers[asm_reg1]\n                mcode.push(reg1)\n\n                let asm_reg2 = asm_code[i + 2]\n                let reg2 = registers[asm_reg2]\n                mcode.push(reg2)\n\n                i += 3\n                offset += 3\n                this.fillValidLine(3)\n            } else if (code == 'jump_from_register') {\n                mcode.push(instructions[code])\n\n                let asm_reg1 = asm_code[i + 1]\n                let reg1 = registers[asm_reg1]\n                mcode.push(reg1)\n\n                i += 2\n                offset += 2\n                this.fillValidLine(2)\n            } else if (code.indexOf('@') != -1 || code.indexOf('#') != -1) {\n                let tag = mcode.length\n                label_map.set(code, tag)\n                i += 1\n            } else if (code == '.memory') {\n                let cnt = parseInt(asm_code[i + 1]) - mcode.length\n                mcode = fillZero(mcode, cnt) // 再这里填充了.memory的数据用来做函数栈，所以代码段是在这个数据之后\n                offset += cnt\n                i += 2\n                this.fillValidLine(cnt)\n            } else if (code == 'halt') {\n                mcode.push(instructions[code])\n                offset += 1\n                i += 1\n                this.fillValidLine(1)\n            } else {\n                i++\n            }\n        }\n\n        for (var i = 0; i < mcode.length; ++i) {\n            if (label_map.has(mcode[i])) {\n                // log('解除' + mcode[i])\n                label_cnt[mcode[i]] = true\n                var data = label_map.get(mcode[i])\n                data = apart_data(data)\n                mcode[i] = data[0]\n                mcode[i + 1] = data[1]\n            }\n        }\n\n        var keys = Object.keys(label_cnt)\n        for (var i = 0; i < keys.length; ++i) {\n            var k = keys[i]\n            var data = label_cnt[k]\n            if (data == false) {\n                mcode = [k + '未定义']\n            }\n        }\n\n        this.mcode = mcode\n    }\n}\n"]}