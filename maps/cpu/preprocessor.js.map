{"version":3,"sources":["cpu/preprocessor.js"],"names":["update_label_map","scope_map","keys","Object","j","scopes","get_scopes_top","length","del_scopes_top","pop","get_cur_scope","get_cur_func_name","dot_function","code","func_name","log","cur_frame","Map","ret","para_list","slice","k","cur_scope","push","dot_end_function","dot_var","var_name","var_data","assert","dot_load","offset","reg","dot_assign","dot_call_function","var_cnt","const_cnt","temp","ret_offset","local_vars_cnt","ret_var_offset","cur_func_name","f1_offset","ret_var","dot_load_return","load_var1","ans","dot_init","lines","if_line","dot_add","process_if_while","asm_code","fake_code_lines","var1","var2","clear_line","isDigit","split","if_ret","offset_ans","if_scopes","fake_ins","l","indexOf","r","codes","real_code","parseInt","symbol","left_reg","i","std_code","if_codes","dot_if","translate_fake_ins","dot_return_func"],"mappings":"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","file":"../../cpu/preprocessor.js","sourcesContent":["var update_label_map = function(scope_map){\n    var keys = Object.keys(scope_map)\n\n    for (var j = 0; j < keys.length; ++j){\n        var k = keys[j]\n        scope_map[k] += 2\n    }\n    return scope_map\n}\n\n// 1: .var name 10\n// 2: .load name reg\n// 3: .assign reg name\n// 4: .function function_name paras[]\n// 5: .call_function function_name paras[]\n// 6: .return_func\n// 7: .push a1 或 .push name 或 .push 123\n// 8: .pop\n\n\n// 用来存局部变量的栈\n// 结构：每个元素都是map{'function_name': 'name', 'scope': map}\nvar scopes = []\n\nvar get_scopes_top = function(){\n    return scopes[scopes.length-1]\n}\n\nvar del_scopes_top = function(){\n    return scopes.pop()\n}\n\nvar get_cur_scope = function(){\n    var cur_frame = get_scopes_top() // 得到栈帧\n    var cur_scope = cur_frame['scope'] // 得到当前作用域\n    return cur_scope\n}\n\nvar get_cur_func_name = function(){\n    var cur_frame = get_scopes_top() // 得到栈帧\n    var cur_func_name = cur_frame['function_name'] // 得到当前作用域\n    return cur_func_name\n}\n\n// scopes的栈顶就是当前正在翻译的作用域\nvar dot_function = function(code){\n    // .function function_name paras[]\n    // 函数名\n    var func_name = code[1]\n    log('函数名:', func_name)\n\n    var cur_frame = new Map() // 新建作用域\n    cur_frame['function_name'] = func_name\n    var cur_scope = new Map() // 当前作用域，在当前作用域中设置变量\n\n    // 作用域入栈\n    var ret = '#' + func_name\n\n    // 处理参数列表\n    var para_list = code.slice(2)\n\n    for (var k = 0; k < para_list.length; ++k){\n        var para = para_list[k]\n        cur_scope[para] = 0\n        update_label_map(cur_scope)\n    }\n\n\n    cur_frame['scope'] = cur_scope\n    scopes.push(cur_frame)\n    return ret\n}\n\nvar dot_end_function = function(code){\n    // 出栈 + 设置标记\n    // .end_function function_name\n    var func_name = code[1]\n    var ret = '#end_' + func_name\n\n    del_scopes_top() // 当前作用域结束了, 后面应该加上检查的方式，必须是闭合的\n    return ret\n}\n\nvar dot_var = function(code){\n    // .var name 10\n    var cur_scope = get_cur_scope()\n\n    // 需要做判断\n    if (code.length < 2){\n        assert(false, '.var语法错误')\n        return\n    }\n    var var_name = code[1]\n    var var_data = 0\n\n    if (cur_scope[var_name]!=null){\n        assert(false, '变量已定义')\n    }\n\n    if (code.length == 3){\n        var_data = code[2]\n    }\n    cur_scope[var_name] = 0\n    var ret =\n'set2 a3 ' + var_data +\n`\nsave_from_register2 a3 f1\nset2 a3 2\nadd2 f1 a3 f1\n`\n    // .var需要更新f1，所以对该frame进行刷新\n    update_label_map(cur_scope)\n\n    // log('scopes:', scopes)\n    return ret\n}\n\nvar dot_load = function(code){\n    // .load name reg\n    var cur_scope = get_cur_scope()\n    var var_name = code[1]\n    var reg = code[2]\n\n    // 先把变量的偏移取出\n    var offset = cur_scope[var_name]\n    var ret =\n'\\nset2 a3 ' + offset +\n`\nsubtract2 f1 a3 a3\n`\n+ 'load_from_register2 a3 ' + reg\n\n    return ret\n}\n\nvar dot_assign = function(code){\n    // .assign reg name\n    // assign 可以拓展很多\n    var cur_scope = get_cur_scope() // 得到当前作用域\n    var reg = code[1]\n    var var_name = code[2]\n\n    // 先把变量的偏移取出\n    var offset = cur_scope[var_name]\n\n    var ret =\n'set2 a3 ' + offset +\n`\nsubtract2 f1 a3 a3\n`\n+ 'save_from_register2 ' + reg + ' a3 '\n\n    return ret\n}\n\nvar dot_call_function = function(code){\n    // .call_function function_name paras[]\n    // 函数名\n    var func_name = code[1]\n    var para_list = code.slice(2)\n\n    var cur_scope = get_cur_scope()\n\n    // 统计字面量、变量\n    var var_cnt = 0\n    var const_cnt = 0\n    for (var k = 0; k < para_list.length; ++k){\n        if (isDigit(para_list[k])){\n            const_cnt += 15\n        } else {\n            var_cnt += 22\n        }\n    }\n    // 先计算返回的pa偏移位置\n    var ret_offset = var_cnt + const_cnt + 14\n\n    // 每调用一次f1的更新都需要刷新frame\n    update_label_map(cur_scope)\n    var ret =\n'set2 a3 ' + ret_offset +\n`\nadd2 pa a3 a3\nsave_from_register2 a3 f1\nset2 a3 2\nadd2 f1 a3 f1\n`\n    for (var k = 0; k < para_list.length; ++k){\n        if (isDigit(para_list[k])){\n            const_cnt += 15\n        } else {\n            // 是变量\n            var var_name = para_list[k]\n            // 变量的偏移\n            var var_offset = cur_scope[var_name]\n            var temp =\n'\\nset2 a3 ' + var_offset +\n`\nsubtract2 f1 a3 a3\nload_from_register2 a3 a3\nsave_from_register2 a3 f1\nset2 a3 2\nadd2 f1 a3 f1\n`\n            ret += temp\n            // 每一步都需要更新偏移\n            update_label_map(cur_scope)\n        }\n    }\n    ret += 'jump ' + '#' + func_name\n\n    log('scopes:', scopes)\n    return ret\n}\n\nvar dot_return_func = function(code){\n    // .return_func\n    // 无参数的话，则只退回所有变量占的空间+2\n    // 将当前函数的所有变量删掉\n    var cur_scope = get_cur_scope()\n\n    var local_vars_cnt = Object.keys(cur_scope).length // 所有局部变量的个数，包括参数\n    var f1_offset = local_vars_cnt * 2 // f1应该退回的数量, 再加上一个f1的位置\n\n    var ret_var = null\n    if (code.length >= 2){\n        ret_var = code[1]\n    }\n\n    var ret = ''\n    if (ret_var!=null){\n        // 有返回值，先看返回变量在不在当前栈中,再栈中就取值\n        if (cur_scope[ret_var] != null){\n            // 由于我们是先把f1退回到存放返回值的位置，所以，f1先变了，那么变量的偏移肯定也需要变，\n            // 现在的错误相当于变量被销毁了，找不到了\n            // 而在这时，我们的a1或者a2是不用的， 于是我们先把返回值在销毁前保存到a1或者a2中\n            var ret_var_offset = cur_scope[ret_var]\n            ret =\n'set2 a3 ' + ret_var_offset +\n`\nsubtract2 f1 a3 a3\nload_from_register2 a3 a1\n` +\n'set2 a3 ' + f1_offset +\n`\nsubtract2 f1 a3 f1 ;f1退栈\n` +\n'save_from_register2 a1 f1' +\n`\nset2 a3 2\nsubtract2 f1 a3 f1 ;再移回到返回值位置\nload_from_register2 f1 a3\njump_from_register a3\n`\n        }\n    } else{\n        // 没有变量的话，就直接退回\n        // 如果是main函数则不用+2，main函数是最外层函数，不退栈\n        var cur_func_name = get_cur_func_name()\n        if (cur_func_name == 'main'){\n            ret =\n'set2 a3 ' + f1_offset +\n`\nsubtract2 f1 a3 f1 ;f1退栈\n`\n        } else{\n            f1_offset += 2\n            ret =\n'set2 a3 ' + f1_offset +\n`\nsubtract2 f1 a3 f1 ;f1退栈\nload_from_register2 f1 a3\njump_from_register a3\n`\n        }\n\n    }\n    return ret\n}\n\nvar dot_load_return = function(code){\n    // .load_return name\n    // 将函数的返回值放入name\n    var cur_scope = get_cur_scope()\n    // 需要做判断\n    if (code.length < 2){\n        assert(false, '.load_return语法错误')\n        return\n    }\n    var var_name = code[1]\n\n    if (cur_scope[var_name]!=null){\n        assert(false, 'load_return中变量未定义')\n    }\n    cur_scope[var_name] = 0\n    var ret =\n`\nset2 a3 2\nadd2 f1 a3 a3\nload_from_register2 a3 a3\nsave_from_register2 a3 f1 ;把值放到f1处\nset2 a3 2\nadd2 f1 a3 f1\n`\n    update_label_map(cur_scope)\n    return ret\n}\n\nvar dot_add = function(code){\n    // .add var1 var2 var3\n    // var3必须是变量，var1和var2可能是字面量\n    //由于该指令会用到其他伪指令，所以直接在其中调用即可\n    if (code.length < 4){\n        assert(false, 'add语法出错')\n    }\n    var cur_scope = get_cur_scope()\n\n    var var1 = code[1]\n    var var2 = code[2]\n    var ans = code[3]\n    var offset_ans = cur_scope[ans]\n\n    var load_var1 = '' // 第1个参数的翻译\n    var load_var2 = '' // 第2个参数的翻译\n    if (isDigit(var1)){\n        log('参数1是数字')\n        load_var1 = '\\nset2 a1 ' + var1 + '\\n'\n    } else {\n        load_var1 = dot_load(('.load ' + var1 + ' a1').split(' '))\n    }\n\n    if (isDigit(var2)){\n        log('参数2是数字')\n        load_var2 = '\\nset2 a2 ' + var2 + '\\n'\n    } else {\n        load_var2 = dot_load(('.load ' + var2 + ' a2').split(' '))\n    }\n\n    var ret = load_var1 + load_var2\n    ret +=\n`\nadd2 a1 a2 a1\n`\n+\n'set2 a3 ' + offset_ans +\n`\nsubtract2 f1 a3 a3\nsave_from_register2 a1 a3\n`\n\n    return ret\n}\n\nvar dot_init = function(code){\n    var ret = `\njump @1024\n.memory 1024\nset2 f1 3 ;一开始设置到栈顶\njump #main ;直接跳到main函数\n`\n    return ret\n}\n\n\nvar if_scopes = []\nvar dot_if = function(code){\n    var lines = code.split('\\n')\n    var if_line = lines[0]\n\n    var l = if_line.indexOf('(')\n    var r = if_line.indexOf(')')\n    var expr = if_line.slice(l+1, r)\n\n    var codes = expr.split(' ')\n    var left_reg = codes[0]\n    var symbol = codes[1]\n    var right_reg = codes[2]\n    log(left_reg, symbol, right_reg)\n\n    var i = 1\n    // while (i < lines.length){\n    //     if (lines[i].indexOf('.if') != -1){\n    //         // 又有嵌套的.if\n    //         process_if_while()\n    //     }\n    // }\n\n\n    return code\n}\n\n///先翻译.if，成带有jump的作用域，其中可能有伪指令，再针对他们进行翻译\nvar process_if_while = function(asm_code){\n    var asm_code = asm_code.split('\\n')\n    var i = 0\n    var fake_code_lines = ''\n\n    while (i < asm_code.length) {\n        code = clear_line(asm_code[i])\n        if (code.length != 0) {\n            if (code.indexOf('.if') != -1) {\n                // 包含.if的语句, 往下找到反花括号\n                var if_codes = ''\n                while (code.indexOf('}') == -1){\n                    if_codes += code + '\\n'\n                    ++i\n                    code = clear_line(asm_code[i])\n                }\n                var if_ret = dot_if(if_codes + '}\\n')\n\n                fake_code_lines += if_ret + '\\n'\n            } else{\n                //其他语句直接往里面塞\n                fake_code_lines += code + '\\n'\n            }\n        }\n        ++i\n    }\n    return fake_code_lines\n}\n\nvar translate_fake_ins = function(asm_code){\n    var ret = []\n    var std_code = ''\n    var asm_code = asm_code.split('\\n')\n    var i = 0\n\n    while (i < asm_code.length) {\n        var code = clear_line(asm_code[i])\n        if (code.length != 0) {\n            // 如果是反括号，则判断if_scope是否为空，如果为空则判断while..\n            //不为空则是if语句的作用域结尾，将if作用域出栈一个即可\n            if (code[0] == '}'){\n                if (if_scopes.length != 0){\n                    if_scopes.pop()\n                }\n            }\n            if (code[0] == '.' && code.indexOf('memory') == -1) {\n                // 处理伪指令\n                code = code.split(' ')\n                fake_ins = code[0]\n                // log('伪指令:', fake_ins)\n                var real_code = ''\n\n                if (fake_ins == '.call'){\n                    real_code = `\nset2 a3 14\nadd2 pa a3 a3\nsave_from_register2 a3 f1\nset2 a3 2\nadd2 f1 a3 f1\njump ` + code[1]\n                } else if (fake_ins == '.return'){\n                    var offset = 2 +parseInt(code[1])\n                    real_code =\n'set2 a3 ' + offset + `\nsubtract2 f1 a3 f1\nload_from_register2 f1 a3\njump_from_register a3 `\n                }\n                else if (fake_ins == '.var'){\n                    real_code = dot_var(code)\n                } else if (fake_ins == '.function'){\n                    real_code = dot_function(code)\n                } else if (fake_ins == '.load'){\n                    real_code = dot_load(code)\n                } else if (fake_ins == '.assign'){\n                    real_code = dot_assign(code)\n                } else if (fake_ins == '.end_function'){\n                    real_code = dot_end_function(code)\n                } else if (fake_ins == '.call_function'){\n                    real_code = dot_call_function(code)\n                } else if (fake_ins == '.return_func'){\n                    real_code = dot_return_func(code)\n                } else if (fake_ins == '.load_return'){\n                    real_code = dot_load_return(code)\n                } else if (fake_ins == '.add'){\n                    real_code = dot_add(code)\n                } else if (fake_ins == '.init'){\n                    real_code = dot_init(code)\n                } else if (fake_ins == '.if'){\n                    real_code = dot_if(code)\n                }\n\n                std_code += real_code + '\\n'\n            } else {\n                if (code.length != 0) {\n                    std_code += code + '\\n'\n                }\n            }\n        }\n        i++\n    }\n    // log('标准代码:\\n', std_code)\n    return std_code\n}\n"]}