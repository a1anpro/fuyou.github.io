jump @1024
.memory 1024

set2 f1 3
jump @function_end

@function_multiply
;局部变量应该存在栈上
; a
save_from_register2 a1 f1
set2 a1 2
add2 f1 a1 f1

; b
save_from_register2 a2 f1
set2 a2 2
add2 f1 a2 f1

; s = 0
set2 a1 0
save_from_register2 a1 f1
set2 a1 2
add2 f1 a1 f1

; i = 0
set2 a1 0
save_from_register2 a1 f1
set2 a1 2
add2 f1 a1 f1

@while_start
; i=f1-2, s=f1-4, b=s1-6, a=s1-8

; i->a1
set2 a1 2
subtract2 f1 a1 a1
load_from_register2 a1 a1

; b->a2
set2 a2 6
subtract2 f1 a2 a2
load_from_register2 a2 a2


compare a1 a2
jump_if_less @while_block
jump @while_end

@while_block
; load a->a1
set2 a1 8
subtract2 f1 a1 a1
load_from_register2 a1 a1

; load s->a2
set2 a2 4
subtract2 f1 a2 a2
load_from_register2 a2 a2

add2 a1 a2 a2

; save s->f1-4
set2 a1 4
subtract2 f1 a1 a1
save_from_register2 a2 a1

; load i->a2
set2 a2 2
subtract2 f1 a2 a2
load_from_register2 a2 a2

set2 a1 1
add2 a1 a2 a2

; save i->f1-2
set2 a1 2
subtract2 f1 a1 a1
save_from_register2 a2 a1


jump @while_start
@while_end

; load s->a1
set2 a1 4
subtract2 f1 a1 a1
load_from_register2 a1 a1
.return 8

;内存f1-2寸的是函数调用前保存的下一条指令的地址
set2 a3 2
subtract2 f1 a3 f1

load_from_register2 f1 a3
jump_from_register a3


@function_end
;设置参数调用函数
set2 a1 10
set2 a2 3

;参数设置好了之后就可以调用函数了
.call @function_multiply

halt
