内存布局：
高地址
f1->
    局部变量1
    局部变量2
    参数1
    参数2
    返回地址1
call->
    局部变量1
    局部变量2

1.先规划好内存布局，实现之后再来想怎样的布局是更好的（方法：看其他聚聚的思路）
2.实现基础伪指令，再添加
    2.1 - 需要什么指令就加什么指令，现在是在写函数的时候用到了局部变量，重复的代码很多，需要抽象
    2.2 - 函数分为两种，
        先考虑如何实现局部变量，不加作用域
        一种是函数定义:定义是死的，只要有一个标记可以跳转就可，
                     再被调用的时候按照参数列表设置参数空间
        一种是函数调用:调用是活的，先实现调用，需要设置参数



前言
随便看看就好, 大段文字警告!!!!

内容编排如下:

1.伪指令设计
2.实现细节
3.函数调用的例子
4.如何一步步实现伪指令
5.其他
阅读顺序推荐:

4. 如何一步步实现伪指令 4.2 我的设计过程
1. 伪指令设计
2. 实现细节
3. 函数调用的例子
5.其他


1.伪指令设计
.function
普通实现

; 定义函数开始的地方
; 加这个是为了区分 (jump @地址) 和 (jump @函数名)

.function function_name

; 预处理指令展开
jump @function_name_end
@function_name

; 这里还是要手动在函数结尾加上 @function_name_end
; 也可以专门 添加一个伪指令 .function_end function_name 专门来做这件事
; 以后可以加上 {} , 匹配花括号 将 } 替换为 @function_name_end
.function_end function_name

; 预处理指令展开
@function_name_end
进阶实现

.function add x y
    ; jump @add_end
    ; @add
    ; 将参数 x 存入局部变量
    ; 将参数 y 存入局部变量
    ; .load_arg x a1
    ; .load_arg y a2
    ; .var x a1
    ; .var y a2

这里需要记录 add 这个函数 有两个变量 x y, 用字典存储这个信息
function_define = {
    'add': ['x', 'y']
}
进一步优化

.function add (x, y) {}
这里比较麻烦: 要匹配花括号, 最后一个花括号 } 就是 @add_end
暂时没想好怎么解析文本: 匹配花括号
.var
普通实现

; 将变量 name 的值 存入内存
.var name 1

; 1.存入内存
set2 a3 1
save_from_regitster2 a3 f1

; 2.将 f1 指向下一个内存
set2 a3 2
add2 f1 a3 f1 ; f1 + 2

; 预处理环节
读到 .var name 10
将变量名 name 作为 key
将变量 name 的值 和 第几次声明变量(假设 name 是第一个声明的变量) 作为 value
; 在 **实现细节** 中解释如何计算第几次声明变量
; 存入字典
{
    'name' = [10, 1],
}

; 关于字典
function_map = {
    'function_1': {},
    'function_2': {},
}
读到 .function 的时候 创建空字典 function_map[function_name] = {}
这里的 key 要加个前缀, 与其他的变量区分开来, 比如 函数add, function_map[function_add] = {}
可以不用删除键名 重名直接覆盖就好了, 这里提供删除的语法 del function_map[function_add]
进阶实现

; 将寄存器的值存入内存
.var name a1
    ; save_from_regitster2 a1 f1
    ; set2 a3 2
    ; add2 f1 a3 f1 ; f1 + 2
.load
普通实现

; 将变量 name 的值 取出
.load name a3
1.从字典中获取 name 的值和偏移
map = function_map
value = map[name][0]
index = map[name][1]
; n 是现在有几个变量
; +1 是因为 n 是从 1 开始计数的, 为了写的时候不用考虑 -1
; 拿纸笔列出 f1 和 变量的对应关系 就知道这里 offset 是怎么计算的了
offset = (n - index + 1) * 2

2.计算内存的位置
set2 a3 offset
sub2 f1 a3 a3
; 这里不要改变 f1 的值, 否则每步都要考虑 f1 是几
; 只有存的时候 f1 + 2, 其他情况不应该直接操作 f1

3.从内存中取出值给 指定的寄存器 这里是 a3
load_from_register3 a3 a3
; 这里看起来很绕, 其实前面将 a3 赋值
; 是不会影响后面 a3 得到 内存里的值的
进阶实现

; 扩充成 能够取到外部传进来的参数
; 这里将外部参数定义为 arg_ + 参数名的形式
.load arg_name a3

; 通过变量名判断是外部传进来的参数
offset 的计算就不同了:
; 加 1 是因为参数计数是从 1 开始的
arg_offset = 参数总个数 - 第几个参数 + 1
address_offset = 1 ; 地址占 1个内存 2个字节
var_offset = n ; 现在的局部变量个数
; 这里同样需要用纸笔将 f1 和 地址代表的含义 一一对应, 这样才好理解
offset = (arg_offset + address_offset + var_offse) * 2

举例:
1.函数为 add(x, y)
2.获取 arg_y 的内存值
3.内存分布为:
arg_x arg_y address x y temp
; 以 x 的内存起始为 f1
; 这个时候的 f1 是 f1 + 6, 指向新的未使用的内存起始位置

arg_number = 2 ; add(x, y) 有两个参数, 所以参数个数为 2
arg_offset = 2 - 2 ; arg_y 是第二个参数
address_offset = 1 ; 地址占 一个内存 2 个字节
var_offset = 3 ; 现在只有三个局部变量 x y temp
offset = (arg_offset + address_offset + var_offse) * 2
.load_arg
; 将外部传进来的参数 取出给寄存器
.load_arg x a3
; 这里约定 参数命名为 arg_ArgName

; 取出 arg_x 的值给 a3
.load arg_x a3
.call_function
普通实现

.call_function add 10 11
; 参数2 参数1 地址 变量1 变量2
; 根据上面的 .function 我们知道了 函数 add 的参数为 x, y
    .var x 10
    .var y 11
    .call @add
进阶实现

; 这个时候发现, 在函数内部调用函数的话要手动输入值, 这样是不合理的
; 改为通过 变量名 传入参数, 下方的 x1 y1 是变量名
; 不应该通过 寄存器 传入参数, 因为寄存器是有限的
; 传入 add 的外部参数也可以写为
; .call_function add arg_x arg_y
.call_function add x1 y1
    ; 展开为:
    ; .load x1 a1
    ; .var x a1
    ; .load y1 a2
    ; .var y a2
    ; .call @add

; 这里有个问题, 参数同名问题
; 在 add(x, y) 函数中 调用 sub(x1, x1) 这个函数
; add(x, y) 有两个局部变量 x, y
; sub(x, y) 的参数名和 add 的局部变量名相同
; 而向 sub 传入参数会自动获取参数名 x, y
; 这样会覆盖 add 中的局部变量 x y

; 解决方案
; 局部变量名不要和要调用的函数的参数名相同
; 展示没有更好的方案
2.实现细节
1.遇到 .function
    字典存入函数名 function_map[function_name] = {}
    开始计数, 计算声明了几次变量 n = 0
    .return 返回不需要清空 n, 因为可能一个函数中有多个 .return

2.遇到 .var
    n += 1

3.字典中存的值
; add(x, y)
; .call @add 10 11, 函数内用 x1, y1 接住参数
{
    ; 其他变量
    'name': [0, 1]

    ; 函数传进来的参数
    'x': [10, 2],
    'y': [11, 3],
    ; 地址
    'address_add': [address, 3],
    'function_add': {
        ; 内部变量
        'x1': [10, 1],
        'y1': [11, 2],
    },
}
3.函数调用的例子
; 定义
.function add x y
    ; 将参数 x 存入局部变量
    .load_arg x a3
    .var x1 a3

    ; 将参数 y 存入局部变量
    .load_arg y a3
    .var y1 a3

    ; 计算
    .add x1 y1 a1
        ; 展开如下:
        ; .load x1 a1
        ; .load y1 a2
        ; add a1 a2 a1

    ; 函数返回
    .return_function
        ; 展开如下:
        ; .return 4 ; 这里是预处理器帮我们计算的

; 函数结束标识
.function_end add
    ; 展开为:
    ; @add_end ; @function_name_end, function_name 替换为函数名 add

; 调用
; 这里进来 n = 0
.call_function add 10 11
    ; 展开为:
    ; .var x 10
    ; .var y 11
    ; .call @add

halt

4.
伪指令不是凭空出现的, 需要想清楚自己需要什么, 需要解决什么问题
伪指令的名字不是最重要的, 不需要在这上面浪费太多时间,
没有好的名字可以发个话题, 大家一起取名字

1.自己需要什么, 需要解决哪些痛点
    (比如每次存变量到内存都要写那几行, 太麻烦了, 于是就诞生了 .var)
    (有了.var 还不够, 取起来也麻烦, 于是就有了 .load)

2.如何实现, 实现思路
    从简到难, 一点一点向前推进, 一步到位是很难的
    发现重复的地方, 和我们用高级语言写函数一样, 把重复的东西放到函数里
    这里思路一样, 把重复的汇编代码抽象为 伪指令

    2.1 每次使用内存都要敲那几行代码, 这是一个重复的地方, 很不方便

    set a3 10
    save_from_register a3 f1
    set2 a3 2
    add2 f1 a3 f1

    把上方的代码抽象成 伪指令 .var name 10

    2.2 存现在有了, 还需要取, 于是就自然设计了 .load name a1

    2.3 现在问题是怎么通过变量名取到地址中的值, 所以现在需要计算声明了几个变量
        这样就可以通过 变量总数和想要得到第几个变量 获取偏移 offset
        如果有多个函数 这个算法就不对了, 于是有了 .function 标记
        碰到第二个函数 重新计数

    2.4 现在发现 调用函数的方式不对 要手动传参
        .var name 10
        于是现在优化 .var 通过寄存器传参
        .var name a1

    2.5 想要设计成以下内存分配方式
        其他参数 参数1 参数2 地址 变量1 变量2
        修改 .load name a1 计算 offset 的方式, 可以通过变量名获取参数值

    2.6 发现每次调用函数都要声明变量, 不方便, 于是就有了以下方式调用函数:
        .call_function add x y


    3.调整心态
        3.1 不要因为困难而感到害怕, 分解问题, 将大问题分解为小问题, 分解到自己能够处理的地步

        3.2 慢慢来, 作业是为了掌握知识, 感到困难就提问 或者 想想作业的背后是想要我们掌握什么原理, 知道这点问题就有了突破口

        3.3 现在不需要去看别人是怎么实现的, 除非解答的人推荐你看, 现在的主要矛盾是解决当前问题, 先提问, 做完了再去看其他人的实现

        3.4 不要因为其他聚聚的超前而感到沮丧, 掌握了作业背后的原理, 你就可以在这基础上拓展, 做到和聚聚一样好
            你现在做不到是因为基础不扎实, 这也是为什么瓜哥现在不往前推进的原因

    4.如何提升
        4.1 提问, 不懂就问, 提升最快
            这一强化自己提问的能力, 如何把问题说清楚, 如何拆解自己的问题
            提问多了, 就可以用更少的语言精确地表达自己的问题, 花最少的时间解决问题

        4.2 简化问题, 提问获取到解决方案, 拆分任务, 逐步实现
            这一步能够提升结构任务的能力

        4.3 帮助他人, 帮他人解决问题的同时, 也是自己梳理知识的过程, 说不定就解决了自己一直困扰的问题,
            这一步可以巩固和调整自己的知识结构, 发现自己从未发现的问题
    其他
    1.上面列举了一些实现思路, 普通实现和进阶实现
        先从普通开始一点一点升级, 实现顺序你们自己编排, 但是切记由简到难, 不要一步到位

    2.我这里仅是分享了设计的思路, 但是本人还未实现这些 **伪指令**
        上面的大段文字, 也是仅做参考, 实现的细节方面需要实践, 我这里有缺漏和无法自洽的地方是正常的, 因为这是设计阶段
        实现细节需要在实现的时候才知道存在什么问题, 以哪种形式实现
        如果有同学按我的思路实现了, 麻烦 at 我一下, 告诉我, 我的缺漏的地方

    3.写了这么多, 突然实现之前, 设计是很重要的环节, 能够帮助你理清思路, 硬莽是不可取的

    4.希望能够帮助到大家, 觉得有用可以分享给其他同学, 掏粪去了...
